标准的中介者模式 (调停者)
该demo演示了从光驱读取数据，然后通知主板(中介者)，再通过cpu解析,声音和显卡响应这一个过程

IMediator.java 中介者接口 提供changed 接口
CDDriver.java 光驱类 提供数据读写接口 并在数据读写完成后通知终结者发生了自己发生了变化!继承Colleague
Client.java 客户端
Colleague.java 抽象父类 持有中介者对象IMediator 
CPU.java CPU类 继承  Colleague，提供操作解析数据的方法executeData，将CDDriver读取的数据进行分类触发
MainBoard.java 具体的中介者实现者(中介者) 对于CDDriver来说,我只要将读取的数据交给主板就好了,具体的数据解析(cpu.java做了这件事情),CDDriver是不知道的
SoundCard.java 声卡类 只负责处理声音
VideoCard.java 显卡类 只负责处理影像

优点:
1.它将各Colleague解耦 ,Mediator有利于各Colleague间的松耦合，你可以独立的改变和复用各Colleague类和Mediator类。 
2.它对对象如何协作进行了抽象将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。 
缺点:
1.解耦同事类之间的联系的同时，中介者自身也不免任务过重，因为几乎所有的业务逻辑都交代到中介者身上了，可谓是“万众期待”的一个角色了。这就是中介者模式的不足之处了 。
有时候我们根本抽取不了“同事”之间的共性来形成一个 抽象Colleague同事类，这也大大增加了中介者模式的使用难度。

六、 适用性
1）一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。 
2）一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。



